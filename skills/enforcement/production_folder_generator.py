"""
Production Folder Generator Skill
=================================

HARDCODED skill for creating production output folders on the Desktop.
This skill CANNOT be bypassed - all pipeline output MUST go through this generator.

Output Structure (HARDCODED):
~/Desktop/Theater_Production/
├── Unit_X_[UnitName]/
│   ├── Day_XX/
│   │   ├── [PowerPoint].pptx
│   │   ├── [Handout].docx
│   │   ├── lesson_plan.md
│   │   ├── exit_ticket.md
│   │   ├── journal_prompts.md
│   │   └── presenter_notes.txt
│   └── unit_plan.md
└── README.md

Pipeline: Theater Education
"""

import os
import shutil
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime


# =============================================================================
# HARDCODED CONSTANTS (CANNOT BE MODIFIED)
# =============================================================================

# Desktop path detection
def get_desktop_path() -> Path:
    """Get the user's Desktop path."""
    home = Path.home()

    # Try common Desktop locations
    desktop_paths = [
        home / "Desktop",
        home / "desktop",
        Path("/mnt/c/Users") / os.environ.get("USER", "") / "Desktop",  # WSL
    ]

    for path in desktop_paths:
        if path.exists():
            return path

    # Fallback to home directory
    return home


# HARDCODED output location
DESKTOP_PATH = get_desktop_path()
PRODUCTION_ROOT = DESKTOP_PATH / "Theater_Production"

# Required files per lesson
REQUIRED_FILES = {
    "powerpoint": {"extension": ".pptx", "required": True},
    "handout": {"extension": ".docx", "required": False},  # Only if activity requires
    "lesson_plan": {"extension": ".md", "required": True},
    "exit_ticket": {"extension": ".md", "required": True},
    "journal_prompts": {"extension": ".md", "required": True},
    "presenter_notes": {"extension": ".txt", "required": False},
}

# Unit names mapping
UNIT_NAMES = {
    1: "Greek_Theater",
    2: "Commedia_dellArte",
    3: "Romeo_and_Juliet",
    4: "Student_Directed_One_Acts",
}


# =============================================================================
# FOLDER STRUCTURE CREATION
# =============================================================================

def create_production_structure(
    unit_number: int,
    day: int,
    unit_name: str = None
) -> Dict[str, Any]:
    """
    Create the production folder structure on Desktop.

    HARDCODED: Creates ~/Desktop/Theater_Production/Unit_X/Day_XX/

    Args:
        unit_number: Unit number (1-4)
        day: Day number
        unit_name: Optional custom unit name

    Returns:
        Dictionary with paths and status
    """
    # Determine unit folder name
    if unit_name:
        safe_name = unit_name.replace(" ", "_").replace("'", "")
    else:
        safe_name = UNIT_NAMES.get(unit_number, f"Unit_{unit_number}")

    unit_folder_name = f"Unit_{unit_number}_{safe_name}"
    day_folder_name = f"Day_{day:02d}"

    # Build paths
    unit_path = PRODUCTION_ROOT / unit_folder_name
    day_path = unit_path / day_folder_name

    # Create directories
    try:
        PRODUCTION_ROOT.mkdir(parents=True, exist_ok=True)
        unit_path.mkdir(parents=True, exist_ok=True)
        day_path.mkdir(parents=True, exist_ok=True)

        # Create README if doesn't exist
        readme_path = PRODUCTION_ROOT / "README.md"
        if not readme_path.exists():
            _create_readme(readme_path)

        return {
            "status": "success",
            "production_root": str(PRODUCTION_ROOT),
            "unit_path": str(unit_path),
            "day_path": str(day_path),
            "unit_folder": unit_folder_name,
            "day_folder": day_folder_name
        }

    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "production_root": str(PRODUCTION_ROOT)
        }


def _create_readme(path: Path) -> None:
    """Create README for production folder."""
    content = f"""# Theater Education Production Files

Generated by Theater Education Pipeline

## Folder Structure

```
Theater_Production/
├── Unit_1_Greek_Theater/
│   ├── Day_01/
│   │   ├── Unit1_Day01_Greek_Theater.pptx
│   │   ├── handout_activity.docx
│   │   ├── lesson_plan.md
│   │   ├── exit_ticket.md
│   │   └── journal_prompts.md
│   ├── Day_02/
│   └── unit_plan.md
├── Unit_2_Commedia_dellArte/
├── Unit_3_Romeo_and_Juliet/
└── Unit_4_Student_Directed_One_Acts/
```

## File Types

| File | Format | Purpose |
|------|--------|---------|
| PowerPoint | .pptx | Lesson presentation with presenter notes |
| Handout | .docx | Activity worksheet with answer key |
| Lesson Plan | .md | Complete lesson plan with timing |
| Exit Ticket | .md | Assessment questions with rubric |
| Journal Prompts | .md | Reflection prompts and extensions |

## Generated

Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}

---
*Theater Education Pipeline - Hardcoded Production Output*
"""
    path.write_text(content)


# =============================================================================
# FILE COPYING
# =============================================================================

def copy_to_production(
    source_path: Path,
    unit_number: int,
    day: int,
    file_type: str,
    unit_name: str = None
) -> Dict[str, Any]:
    """
    Copy a file to the production folder.

    HARDCODED: All files must be copied to Desktop production folder.

    Args:
        source_path: Path to source file
        unit_number: Unit number
        day: Day number
        file_type: Type of file (powerpoint, handout, lesson_plan, etc.)
        unit_name: Optional unit name

    Returns:
        Result dictionary
    """
    # Ensure production structure exists
    structure = create_production_structure(unit_number, day, unit_name)
    if structure["status"] != "success":
        return structure

    day_path = Path(structure["day_path"])

    # Determine destination filename
    if file_type == "powerpoint":
        unit_safe = UNIT_NAMES.get(unit_number, "Theater")
        dest_name = f"Unit{unit_number}_Day{day:02d}_{unit_safe}.pptx"
    elif file_type == "handout":
        dest_name = f"handout_activity.docx"
    elif file_type == "lesson_plan":
        dest_name = "lesson_plan.md"
    elif file_type == "exit_ticket":
        dest_name = "exit_ticket.md"
    elif file_type == "journal_prompts":
        dest_name = "journal_prompts.md"
    elif file_type == "presenter_notes":
        dest_name = "presenter_notes.txt"
    else:
        dest_name = source_path.name

    dest_path = day_path / dest_name

    try:
        if source_path.exists():
            shutil.copy2(source_path, dest_path)
            return {
                "status": "success",
                "source": str(source_path),
                "destination": str(dest_path),
                "file_type": file_type
            }
        else:
            return {
                "status": "error",
                "error": f"Source file not found: {source_path}",
                "file_type": file_type
            }

    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "file_type": file_type
        }


def copy_all_lesson_files(
    source_dir: Path,
    unit_number: int,
    day: int,
    unit_name: str = None
) -> Dict[str, Any]:
    """
    Copy all lesson files to production folder.

    HARDCODED: Copies all required files to Desktop.

    Args:
        source_dir: Source directory containing lesson files
        unit_number: Unit number
        day: Day number
        unit_name: Optional unit name

    Returns:
        Result dictionary with all copy results
    """
    results = {
        "status": "success",
        "files_copied": [],
        "files_missing": [],
        "errors": []
    }

    # Ensure structure exists
    structure = create_production_structure(unit_number, day, unit_name)
    if structure["status"] != "success":
        return {"status": "error", "error": structure.get("error")}

    # File patterns to look for
    file_patterns = {
        "powerpoint": ["*.pptx"],
        "handout": ["*handout*.docx", "*Handout*.docx"],
        "lesson_plan": ["lesson_plan.md", "lesson*.md"],
        "exit_ticket": ["exit_ticket.md", "exit*.md"],
        "journal_prompts": ["journal_prompts.md", "journal*.md"],
        "presenter_notes": ["presenter_notes.txt", "notes.txt"],
    }

    source_dir = Path(source_dir)

    for file_type, patterns in file_patterns.items():
        found = False
        for pattern in patterns:
            matches = list(source_dir.glob(pattern))
            if matches:
                # Copy first match
                result = copy_to_production(
                    matches[0], unit_number, day, file_type, unit_name
                )
                if result["status"] == "success":
                    results["files_copied"].append({
                        "type": file_type,
                        "source": str(matches[0]),
                        "destination": result["destination"]
                    })
                    found = True
                else:
                    results["errors"].append(result)
                break

        if not found:
            file_info = REQUIRED_FILES.get(file_type, {})
            if file_info.get("required", False):
                results["files_missing"].append(file_type)

    # Update status if any required files missing
    if results["files_missing"]:
        results["status"] = "partial"

    if results["errors"]:
        results["status"] = "error"

    return results


# =============================================================================
# FULL PRODUCTION EXPORT
# =============================================================================

def export_lesson_to_production(
    lesson_data: Dict[str, Any],
    source_dir: Path,
    unit_number: int,
    day: int,
    unit_name: str = None
) -> Dict[str, Any]:
    """
    Full export of lesson to production folder.

    HARDCODED: Complete lesson export to Desktop.

    Args:
        lesson_data: Lesson data dictionary (for generating missing files)
        source_dir: Source directory
        unit_number: Unit number
        day: Day number
        unit_name: Optional unit name

    Returns:
        Complete export result
    """
    export_time = datetime.now()

    # Create structure
    structure = create_production_structure(unit_number, day, unit_name)
    if structure["status"] != "success":
        return structure

    # Copy all files
    copy_result = copy_all_lesson_files(source_dir, unit_number, day, unit_name)

    # Build export manifest
    day_path = Path(structure["day_path"])
    manifest = {
        "export_time": export_time.isoformat(),
        "unit_number": unit_number,
        "day": day,
        "unit_name": unit_name or UNIT_NAMES.get(unit_number),
        "production_path": str(day_path),
        "files": []
    }

    # List all files in production folder
    for file_path in day_path.iterdir():
        if file_path.is_file():
            manifest["files"].append({
                "name": file_path.name,
                "size_bytes": file_path.stat().st_size,
                "type": file_path.suffix
            })

    return {
        "status": copy_result["status"],
        "structure": structure,
        "copy_result": copy_result,
        "manifest": manifest,
        "production_path": str(day_path)
    }


# =============================================================================
# QUICK ACCESS FUNCTIONS
# =============================================================================

def get_production_path(unit_number: int, day: int) -> Path:
    """Get the production path for a specific lesson."""
    unit_name = UNIT_NAMES.get(unit_number, f"Unit_{unit_number}")
    return PRODUCTION_ROOT / f"Unit_{unit_number}_{unit_name}" / f"Day_{day:02d}"


def list_production_contents() -> Dict[str, Any]:
    """List all contents of production folder."""
    if not PRODUCTION_ROOT.exists():
        return {"status": "empty", "units": []}

    units = []
    for unit_dir in sorted(PRODUCTION_ROOT.iterdir()):
        if unit_dir.is_dir() and unit_dir.name.startswith("Unit_"):
            unit_info = {
                "name": unit_dir.name,
                "path": str(unit_dir),
                "days": []
            }
            for day_dir in sorted(unit_dir.iterdir()):
                if day_dir.is_dir() and day_dir.name.startswith("Day_"):
                    files = [f.name for f in day_dir.iterdir() if f.is_file()]
                    unit_info["days"].append({
                        "name": day_dir.name,
                        "files": files,
                        "file_count": len(files)
                    })
            units.append(unit_info)

    return {
        "status": "success",
        "production_root": str(PRODUCTION_ROOT),
        "units": units,
        "total_units": len(units)
    }


def open_production_folder(unit_number: int = None, day: int = None) -> str:
    """
    Get the command to open production folder.

    Returns the path that can be opened.
    """
    if unit_number and day:
        path = get_production_path(unit_number, day)
    elif unit_number:
        unit_name = UNIT_NAMES.get(unit_number, f"Unit_{unit_number}")
        path = PRODUCTION_ROOT / f"Unit_{unit_number}_{unit_name}"
    else:
        path = PRODUCTION_ROOT

    return str(path)


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    # Main functions
    "create_production_structure",
    "copy_to_production",
    "copy_all_lesson_files",
    "export_lesson_to_production",
    # Quick access
    "get_production_path",
    "list_production_contents",
    "open_production_folder",
    # Constants
    "PRODUCTION_ROOT",
    "DESKTOP_PATH",
    "REQUIRED_FILES",
    "UNIT_NAMES",
]
